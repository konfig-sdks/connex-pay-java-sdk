/*
 * ConnexPay Reporting API
 * REST API for retrieving reporting data. Currently Daily Accounting data only.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.time.LocalDate;
import com.konfigthis.client.model.SaleCreateTransaction201Response;
import com.konfigthis.client.model.SaleCreateTransactionRequest;
import com.konfigthis.client.model.SaleCreateTransactionRequestBankAccount;
import com.konfigthis.client.model.SaleCreateTransactionRequestBrowserData;
import com.konfigthis.client.model.SaleCreateTransactionRequestCard;
import com.konfigthis.client.model.SaleCreateTransactionRequestConnexPayTransaction;
import com.konfigthis.client.model.SaleCreateTransactionRequestCustomParametersInner;
import com.konfigthis.client.model.SaleCreateTransactionRequestCustomer;
import com.konfigthis.client.model.SaleCreateTransactionRequestEnhancedData;
import com.konfigthis.client.model.SaleCreateTransactionRequestRiskData;
import com.konfigthis.client.model.SaleCreateTransactionResponse;
import com.konfigthis.client.model.SaleSearchSalesRequest;
import com.konfigthis.client.model.SaleSearchSalesResponse;
import com.konfigthis.client.model.SaleUpdateDelayedActivationRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class SaleApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public SaleApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public SaleApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call activateDelayedCall(String saleGuid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/sales/Activate/{SaleGuid}"
            .replace("{" + "SaleGuid" + "}", localVarApiClient.escapeString(saleGuid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "sec0" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call activateDelayedValidateBeforeCall(String saleGuid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'saleGuid' is set
        if (saleGuid == null) {
            throw new ApiException("Missing the required parameter 'saleGuid' when calling activateDelayed(Async)");
        }

        return activateDelayedCall(saleGuid, _callback);

    }


    private ApiResponse<Object> activateDelayedWithHttpInfo(String saleGuid) throws ApiException {
        okhttp3.Call localVarCall = activateDelayedValidateBeforeCall(saleGuid, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call activateDelayedAsync(String saleGuid, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = activateDelayedValidateBeforeCall(saleGuid, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ActivateDelayedRequestBuilder {
        private final String saleGuid;

        private ActivateDelayedRequestBuilder(String saleGuid) {
            this.saleGuid = saleGuid;
        }

        /**
         * Build call for activateDelayed
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return activateDelayedCall(saleGuid, _callback);
        }


        /**
         * Execute activateDelayed request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = activateDelayedWithHttpInfo(saleGuid);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute activateDelayed request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return activateDelayedWithHttpInfo(saleGuid);
        }

        /**
         * Execute activateDelayed request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return activateDelayedAsync(saleGuid, _callback);
        }
    }

    /**
     * Activate Delayed Sale
     * Activate a delayed activation sale independent of the activation date for which the sale was created.  A client can \&quot;Activate\&quot; a delayed activation sale this way at any time before ConnexPay will automatically activate it during the early hours of the supplied future date.
     * @param saleGuid The sale guid returned upon initial creation of the delayed activation sale. (required)
     * @return ActivateDelayedRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
     </table>
     */
    public ActivateDelayedRequestBuilder activateDelayed(String saleGuid) throws IllegalArgumentException {
        if (saleGuid == null) throw new IllegalArgumentException("\"saleGuid\" is required but got null");
            

        return new ActivateDelayedRequestBuilder(saleGuid);
    }
    private okhttp3.Call createTransactionCall(SaleCreateTransactionRequest saleCreateTransactionRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = saleCreateTransactionRequest;

        // create path and map variables
        String localVarPath = "/api/v1/sales";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "sec0" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createTransactionValidateBeforeCall(SaleCreateTransactionRequest saleCreateTransactionRequest, final ApiCallback _callback) throws ApiException {
        return createTransactionCall(saleCreateTransactionRequest, _callback);

    }


    private ApiResponse<SaleCreateTransactionResponse> createTransactionWithHttpInfo(SaleCreateTransactionRequest saleCreateTransactionRequest) throws ApiException {
        okhttp3.Call localVarCall = createTransactionValidateBeforeCall(saleCreateTransactionRequest, null);
        Type localVarReturnType = new TypeToken<SaleCreateTransactionResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createTransactionAsync(SaleCreateTransactionRequest saleCreateTransactionRequest, final ApiCallback<SaleCreateTransactionResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createTransactionValidateBeforeCall(saleCreateTransactionRequest, _callback);
        Type localVarReturnType = new TypeToken<SaleCreateTransactionResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateTransactionRequestBuilder {
        private final String deviceGuid;
        private final Float amount;
        private final SaleCreateTransactionRequestConnexPayTransaction connexPayTransaction;
        private final SaleCreateTransactionRequestRiskData riskData;
        private String tenderType;
        private String sequenceNumber;
        private String orderNumber;
        private Boolean sendReceipt;
        private Boolean riskProcessingOnly;
        private String statementDescription;
        private String customerID;
        private LocalDate activationDate;
        private String requestIp;
        private SaleCreateTransactionRequestCard card;
        private SaleCreateTransactionRequestBankAccount bankAccount;
        private SaleCreateTransactionRequestCustomer customer;
        private SaleCreateTransactionRequestEnhancedData enhancedData;
        private String associationId;
        private List<SaleCreateTransactionRequestCustomParametersInner> customParameters;
        private List<String> labelIDs;
        private SaleCreateTransactionRequestBrowserData browserData;

        private CreateTransactionRequestBuilder(String deviceGuid, Float amount, SaleCreateTransactionRequestConnexPayTransaction connexPayTransaction, SaleCreateTransactionRequestRiskData riskData) {
            this.deviceGuid = deviceGuid;
            this.amount = amount;
            this.connexPayTransaction = connexPayTransaction;
            this.riskData = riskData;
        }

        /**
         * Set tenderType
         * @param tenderType Allowed values:  \\\&quot;credit\\\&quot; (default if TenderType not provided) and \\\&quot;ach\\\&quot; (optional, default to credit)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder tenderType(String tenderType) {
            this.tenderType = tenderType;
            return this;
        }
        
        /**
         * Set sequenceNumber
         * @param sequenceNumber Transaction sequence number within client environment. Provide a unique SequenceNumber for each new request. If a sale request with the same parameter data and the same sequence number is sent within 30 minutes it will be considered a duplicate request and the sale will not process. Note: value is not searchable or reportable in Bridge.  Alphanumeric. (optional, default to {{SequenceNumber}})
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder sequenceNumber(String sequenceNumber) {
            this.sequenceNumber = sequenceNumber;
            return this;
        }
        
        /**
         * Set orderNumber
         * @param orderNumber This is the most common number you&#39;ll see throughout the ConnexPay Portal.  Transaction ID within client environment associated with the order. The value is searchable and reportable in the ConnexPay portal. This value may be sent in multiple instances of the integration for multiple purposes. Customers in the travel space often send the Record Locator/PNR in this field.  The maximum length is 50 alpha-numeric characters and allows dashes ( - ). (optional, default to {{OrderNumber}})
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder orderNumber(String orderNumber) {
            this.orderNumber = orderNumber;
            return this;
        }
        
        /**
         * Set sendReceipt
         * @param sendReceipt Value determines whether or not a customer shall be emailed a receipt from the ConnexPay platform if the email address is provided in the API customer block. The default value is TRUE. Set to FALSE so that an email receipt is not sent to the customer. Set to TRUE or leave empty if you want e-mail to be sent. If TRUE, customer&#39;s email must be included in the \\\&quot;Card.Customer.email\\\&quot; parameter. (optional)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder sendReceipt(Boolean sendReceipt) {
            this.sendReceipt = sendReceipt;
            return this;
        }
        
        /**
         * Set riskProcessingOnly
         * @param riskProcessingOnly Indicator that determines if client would like to evaluate the transactions as risk only rather than process as merchant of record and create a virtual card. The allowed values:  1. Set to TRUE will only run risk validations. If TenderType is not set to Credit, setting TRUE will throw a validation error.  2. Set to FALSE will run risk validations and an authorization on the card. For this option a Processing Merchant account is required, contact ConnexPay support if any questions.  3. Set to NULL and your Merchant Level settings would apply. (optional)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder riskProcessingOnly(Boolean riskProcessingOnly) {
            this.riskProcessingOnly = riskProcessingOnly;
            return this;
        }
        
        /**
         * Set statementDescription
         * @param statementDescription US Clients only: The statement description allows a client to customize the Merchant name that appears on the cardholder statement such that the cardholder recognizes the transaction on their statement. For US Merchants: ConnexPay recommends sending a recognizable DBA along with the PNR i.e. ABC Travel ABC123.  The maximum length is 25 alpha-numeric characters.  For EU Merchants: The maximum length of the description is 13 alphanumeric characters and the DBA Name and City will automatically be coded to appear as part of the statement description. Note: functionality not applicable for American Express program. (optional, default to {{StatementDescription}})
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder statementDescription(String statementDescription) {
            this.statementDescription = statementDescription;
            return this;
        }
        
        /**
         * Set customerID
         * @param customerID Transaction ID within client environment associated with the customer. This value acts as a secondary identifier in conjunction with OrderNumber. The value is searchable and reportable in the ConnexPay portal. This value may be sent in multiple times within the integration for multiple purposes.  The maximum length is 100 characters and is alpha-numeric. (optional)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder customerID(String customerID) {
            this.customerID = customerID;
            return this;
        }
        
        /**
         * Set activationDate
         * @param activationDate Set a future date on which to run this sale, at least one day from creation date and within 600 days. If this parameter is supplied a record for this sale is created, supplied consumer card information is internally tokenized, but fraud check and authorization do not occur until ConnexPay processes it on the supplied ActivationDate. Alternatively, a client can force activation via the Activate API (see below). If this date is not supplied a sale is authorized and the consumer&#39;s credit card is charged immediately. (optional)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder activationDate(LocalDate activationDate) {
            this.activationDate = activationDate;
            return this;
        }
        
        /**
         * Set requestIp
         * @param requestIp Mandatory if TenderType is ACH. Customer&#39;s IP Address is a required parameter for all ACH Sales transactions to adhere to NACHA regulations. (optional)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder requestIp(String requestIp) {
            this.requestIp = requestIp;
            return this;
        }
        
        /**
         * Set card
         * @param card  (optional)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder card(SaleCreateTransactionRequestCard card) {
            this.card = card;
            return this;
        }
        
        /**
         * Set bankAccount
         * @param bankAccount  (optional)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder bankAccount(SaleCreateTransactionRequestBankAccount bankAccount) {
            this.bankAccount = bankAccount;
            return this;
        }
        
        /**
         * Set customer
         * @param customer  (optional)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder customer(SaleCreateTransactionRequestCustomer customer) {
            this.customer = customer;
            return this;
        }
        
        /**
         * Set enhancedData
         * @param enhancedData  (optional)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder enhancedData(SaleCreateTransactionRequestEnhancedData enhancedData) {
            this.enhancedData = enhancedData;
            return this;
        }
        
        /**
         * Set associationId
         * @param associationId Utilize the Association ID field to tie a virtual card to a sale or sales. For example, if you have several sales and one virtual card payment to a supplier, you can add association ID to the sales and the virtual card for downstream reporting. (optional)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder associationId(String associationId) {
            this.associationId = associationId;
            return this;
        }
        
        /**
         * Set customParameters
         * @param customParameters You can add custom parameters to your sale request in the event that you need to associate additional information with the pay-in. For example, if you want to add an invoice number you would include the custom parameters object with the name parameter &#x3D; \\\&quot;invoice\\\&quot; and the value parameter as the invoice number. This requires customized reporting so you&#39;ll need to work with your implementations specialist to determine what&#39;s required. (optional)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder customParameters(List<SaleCreateTransactionRequestCustomParametersInner> customParameters) {
            this.customParameters = customParameters;
            return this;
        }
        
        /**
         * Set labelIDs
         * @param labelIDs Utilize Label IDs to associate a sale to a specific label(s) within ConnexPay Bridge UI for your organization. If a sale is tied to an incorrect Label, it will not filter or display correctly in Bridge&#39;s Search Grid. Please contact your Customer Care Consultant for a list of valid Label IDs before use. (optional)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder labelIDs(List<String> labelIDs) {
            this.labelIDs = labelIDs;
            return this;
        }
        
        /**
         * Set browserData
         * @param browserData  (optional)
         * @return CreateTransactionRequestBuilder
         */
        public CreateTransactionRequestBuilder browserData(SaleCreateTransactionRequestBrowserData browserData) {
            this.browserData = browserData;
            return this;
        }
        
        /**
         * Build call for createTransaction
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
            <tr><td> 201 </td><td> 201 </td><td>  -  </td></tr>
            <tr><td> 202 </td><td> 202 </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SaleCreateTransactionRequest saleCreateTransactionRequest = buildBodyParams();
            return createTransactionCall(saleCreateTransactionRequest, _callback);
        }

        private SaleCreateTransactionRequest buildBodyParams() {
            SaleCreateTransactionRequest saleCreateTransactionRequest = new SaleCreateTransactionRequest();
            saleCreateTransactionRequest.deviceGuid(this.deviceGuid);
            saleCreateTransactionRequest.amount(this.amount);
            saleCreateTransactionRequest.tenderType(this.tenderType);
            saleCreateTransactionRequest.sequenceNumber(this.sequenceNumber);
            saleCreateTransactionRequest.orderNumber(this.orderNumber);
            saleCreateTransactionRequest.sendReceipt(this.sendReceipt);
            saleCreateTransactionRequest.riskProcessingOnly(this.riskProcessingOnly);
            saleCreateTransactionRequest.statementDescription(this.statementDescription);
            saleCreateTransactionRequest.customerID(this.customerID);
            saleCreateTransactionRequest.activationDate(this.activationDate);
            saleCreateTransactionRequest.requestIp(this.requestIp);
            saleCreateTransactionRequest.connexPayTransaction(this.connexPayTransaction);
            saleCreateTransactionRequest.riskData(this.riskData);
            saleCreateTransactionRequest.card(this.card);
            saleCreateTransactionRequest.bankAccount(this.bankAccount);
            saleCreateTransactionRequest.customer(this.customer);
            saleCreateTransactionRequest.enhancedData(this.enhancedData);
            saleCreateTransactionRequest.associationId(this.associationId);
            saleCreateTransactionRequest.customParameters(this.customParameters);
            saleCreateTransactionRequest.labelIDs(this.labelIDs);
            saleCreateTransactionRequest.browserData(this.browserData);
            return saleCreateTransactionRequest;
        }

        /**
         * Execute createTransaction request
         * @return SaleCreateTransactionResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
            <tr><td> 201 </td><td> 201 </td><td>  -  </td></tr>
            <tr><td> 202 </td><td> 202 </td><td>  -  </td></tr>
         </table>
         */
        public SaleCreateTransactionResponse execute() throws ApiException {
            SaleCreateTransactionRequest saleCreateTransactionRequest = buildBodyParams();
            ApiResponse<SaleCreateTransactionResponse> localVarResp = createTransactionWithHttpInfo(saleCreateTransactionRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createTransaction request with HTTP info returned
         * @return ApiResponse&lt;SaleCreateTransactionResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
            <tr><td> 201 </td><td> 201 </td><td>  -  </td></tr>
            <tr><td> 202 </td><td> 202 </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<SaleCreateTransactionResponse> executeWithHttpInfo() throws ApiException {
            SaleCreateTransactionRequest saleCreateTransactionRequest = buildBodyParams();
            return createTransactionWithHttpInfo(saleCreateTransactionRequest);
        }

        /**
         * Execute createTransaction request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
            <tr><td> 201 </td><td> 201 </td><td>  -  </td></tr>
            <tr><td> 202 </td><td> 202 </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<SaleCreateTransactionResponse> _callback) throws ApiException {
            SaleCreateTransactionRequest saleCreateTransactionRequest = buildBodyParams();
            return createTransactionAsync(saleCreateTransactionRequest, _callback);
        }
    }

    /**
     * Create Sale
     * The Create Sale Endpoint is used by acquiring clients. The Sale transaction is used to create a sale for your consumer. You can create a credit sale or an ACH sale (ACH sales apply to US Clients only). A credit sale will charge a consumer&#39;s credit card. The consumer&#39;s credit card will be authorized immediately when the Sales request is received and will automatically settle/batch that same night. In other words, this one Sale request is just like running an AuthOnly and a Capture in one request.You can postpone charging the consumer&#39;s credit card by providing a date in the &#39;ActivationDate&#39; of your request. Doing so will delay the authorization and charge to the consumer&#39;s credit card until that future date.An ACH sale will create an ACH transaction that will debit the consumer&#39;s bank account. ACH sales received prior to 3:00 PM EST will process overnight. ACH Sales received after 3:00 PM EST will process the following night.
     * @return CreateTransactionRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
        <tr><td> 201 </td><td> 201 </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> 202 </td><td>  -  </td></tr>
     </table>
     */
    public CreateTransactionRequestBuilder createTransaction(String deviceGuid, Float amount, SaleCreateTransactionRequestConnexPayTransaction connexPayTransaction, SaleCreateTransactionRequestRiskData riskData) throws IllegalArgumentException {
        if (deviceGuid == null) throw new IllegalArgumentException("\"deviceGuid\" is required but got null");
            

        if (amount == null) throw new IllegalArgumentException("\"amount\" is required but got null");
        if (connexPayTransaction == null) throw new IllegalArgumentException("\"connexPayTransaction\" is required but got null");
        if (riskData == null) throw new IllegalArgumentException("\"riskData\" is required but got null");
        return new CreateTransactionRequestBuilder(deviceGuid, amount, connexPayTransaction, riskData);
    }
    private okhttp3.Call getChargebacksByUserCall(String getByUserQuestionMarkStartDateEqual20161201, String getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, String getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/chargeback/GetByUser"
            .replace("{" + "/GetByUser?startDate&#x3D;2016-12-01" + "}", localVarApiClient.escapeString(getByUserQuestionMarkStartDateEqual20161201.toString()))
            .replace("{" + "/GetByUser?startDate&#x3D;2016-12-01&amp;endDate&#x3D;2016-12-01" + "}", localVarApiClient.escapeString(getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201.toString()))
            .replace("{" + "/GetByResolvedDate?startDate&#x3D;2019-09-20&amp;endDate&#x3D;2019-10-21" + "}", localVarApiClient.escapeString(getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "sec0" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getChargebacksByUserValidateBeforeCall(String getByUserQuestionMarkStartDateEqual20161201, String getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, String getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getByUserQuestionMarkStartDateEqual20161201' is set
        if (getByUserQuestionMarkStartDateEqual20161201 == null) {
            throw new ApiException("Missing the required parameter 'getByUserQuestionMarkStartDateEqual20161201' when calling getChargebacksByUser(Async)");
        }

        // verify the required parameter 'getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201' is set
        if (getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201 == null) {
            throw new ApiException("Missing the required parameter 'getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201' when calling getChargebacksByUser(Async)");
        }

        // verify the required parameter 'getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021' is set
        if (getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021 == null) {
            throw new ApiException("Missing the required parameter 'getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021' when calling getChargebacksByUser(Async)");
        }

        return getChargebacksByUserCall(getByUserQuestionMarkStartDateEqual20161201, getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021, _callback);

    }


    private ApiResponse<String> getChargebacksByUserWithHttpInfo(String getByUserQuestionMarkStartDateEqual20161201, String getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, String getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021) throws ApiException {
        okhttp3.Call localVarCall = getChargebacksByUserValidateBeforeCall(getByUserQuestionMarkStartDateEqual20161201, getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getChargebacksByUserAsync(String getByUserQuestionMarkStartDateEqual20161201, String getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, String getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = getChargebacksByUserValidateBeforeCall(getByUserQuestionMarkStartDateEqual20161201, getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetChargebacksByUserRequestBuilder {
        private final String getByUserQuestionMarkStartDateEqual20161201;
        private final String getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201;
        private final String getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021;

        private GetChargebacksByUserRequestBuilder(String getByUserQuestionMarkStartDateEqual20161201, String getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, String getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021) {
            this.getByUserQuestionMarkStartDateEqual20161201 = getByUserQuestionMarkStartDateEqual20161201;
            this.getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201 = getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201;
            this.getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021 = getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021;
        }

        /**
         * Build call for getChargebacksByUser
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getChargebacksByUserCall(getByUserQuestionMarkStartDateEqual20161201, getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021, _callback);
        }


        /**
         * Execute getChargebacksByUser request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = getChargebacksByUserWithHttpInfo(getByUserQuestionMarkStartDateEqual20161201, getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getChargebacksByUser request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return getChargebacksByUserWithHttpInfo(getByUserQuestionMarkStartDateEqual20161201, getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021);
        }

        /**
         * Execute getChargebacksByUser request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return getChargebacksByUserAsync(getByUserQuestionMarkStartDateEqual20161201, getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021, _callback);
        }
    }

    /**
     * Sales Chargebacks
     * 
     * @param getByUserQuestionMarkStartDateEqual20161201 Return all chargebacks for the authenticated user with a start date (required)
     * @param getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201 Return all chargebacks for the authenticated user with a start and end date (required)
     * @param getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021 Return all chargebacks for the authenticated user with a start and end date based on resolved date (required)
     * @return GetChargebacksByUserRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
     </table>
     */
    public GetChargebacksByUserRequestBuilder getChargebacksByUser(String getByUserQuestionMarkStartDateEqual20161201, String getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, String getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021) throws IllegalArgumentException {
        if (getByUserQuestionMarkStartDateEqual20161201 == null) throw new IllegalArgumentException("\"getByUserQuestionMarkStartDateEqual20161201\" is required but got null");
            

        if (getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201 == null) throw new IllegalArgumentException("\"getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201\" is required but got null");
            

        if (getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021 == null) throw new IllegalArgumentException("\"getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021\" is required but got null");
            

        return new GetChargebacksByUserRequestBuilder(getByUserQuestionMarkStartDateEqual20161201, getByUserQuestionMarkStartDateEqual20161201AmpersandEndDateEqual20161201, getByResolvedDateQuestionMarkStartDateEqual20190920AmpersandEndDateEqual20191021);
    }
    private okhttp3.Call searchSalesCall(String exportable, Integer pageNumber, String pageSize, SaleSearchSalesRequest saleSearchSalesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = saleSearchSalesRequest;

        // create path and map variables
        String localVarPath = "/api/v1/Search/Sales/{exportable}/{pageNumber}/{pageSize}"
            .replace("{" + "Exportable" + "}", localVarApiClient.escapeString(exportable.toString()))
            .replace("{" + "PageNumber" + "}", localVarApiClient.escapeString(pageNumber.toString()))
            .replace("{" + "PageSize" + "}", localVarApiClient.escapeString(pageSize.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "sec0" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchSalesValidateBeforeCall(String exportable, Integer pageNumber, String pageSize, SaleSearchSalesRequest saleSearchSalesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'exportable' is set
        if (exportable == null) {
            throw new ApiException("Missing the required parameter 'exportable' when calling searchSales(Async)");
        }

        // verify the required parameter 'pageNumber' is set
        if (pageNumber == null) {
            throw new ApiException("Missing the required parameter 'pageNumber' when calling searchSales(Async)");
        }

        // verify the required parameter 'pageSize' is set
        if (pageSize == null) {
            throw new ApiException("Missing the required parameter 'pageSize' when calling searchSales(Async)");
        }

        return searchSalesCall(exportable, pageNumber, pageSize, saleSearchSalesRequest, _callback);

    }


    private ApiResponse<SaleSearchSalesResponse> searchSalesWithHttpInfo(String exportable, Integer pageNumber, String pageSize, SaleSearchSalesRequest saleSearchSalesRequest) throws ApiException {
        okhttp3.Call localVarCall = searchSalesValidateBeforeCall(exportable, pageNumber, pageSize, saleSearchSalesRequest, null);
        Type localVarReturnType = new TypeToken<SaleSearchSalesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call searchSalesAsync(String exportable, Integer pageNumber, String pageSize, SaleSearchSalesRequest saleSearchSalesRequest, final ApiCallback<SaleSearchSalesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchSalesValidateBeforeCall(exportable, pageNumber, pageSize, saleSearchSalesRequest, _callback);
        Type localVarReturnType = new TypeToken<SaleSearchSalesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SearchSalesRequestBuilder {
        private final String exportable;
        private final Integer pageNumber;
        private final String pageSize;
        private String merchantGuid;
        private Float amountFrom;
        private Float amountTo;
        private String cardHolderName;
        private String cardLastFour;
        private String cardType;
        private Integer invoiceNumber;
        private String orderNumber;
        private LocalDate orderDateFrom;
        private LocalDate orderDateTo;
        private LocalDate timeStampFrom;
        private LocalDate timeStampTo;
        private String status;
        private String merchantCustomerId;
        private Boolean activated;
        private LocalDate activationDateFrom;
        private LocalDate activationDateTo;

        private SearchSalesRequestBuilder(String exportable, Integer pageNumber, String pageSize) {
            this.exportable = exportable;
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
        }

        /**
         * Set merchantGuid
         * @param merchantGuid Merchants Guid. (optional, default to Mandatory)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder merchantGuid(String merchantGuid) {
            this.merchantGuid = merchantGuid;
            return this;
        }
        
        /**
         * Set amountFrom
         * @param amountFrom Amount of the transaction. Min. amt.: $0.50 (optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder amountFrom(Float amountFrom) {
            this.amountFrom = amountFrom;
            return this;
        }
        
        /**
         * Set amountTo
         * @param amountTo Amount of the transaction. Min. amt.: $0.50 (optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder amountTo(Float amountTo) {
            this.amountTo = amountTo;
            return this;
        }
        
        /**
         * Set cardHolderName
         * @param cardHolderName Cardholders name. (optional, default to Optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder cardHolderName(String cardHolderName) {
            this.cardHolderName = cardHolderName;
            return this;
        }
        
        /**
         * Set cardLastFour
         * @param cardLastFour Card last four number. (optional, default to Optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder cardLastFour(String cardLastFour) {
            this.cardLastFour = cardLastFour;
            return this;
        }
        
        /**
         * Set cardType
         * @param cardType Card type. (optional, default to Optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder cardType(String cardType) {
            this.cardType = cardType;
            return this;
        }
        
        /**
         * Set invoiceNumber
         * @param invoiceNumber Sales InvoiceNumber. (optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder invoiceNumber(Integer invoiceNumber) {
            this.invoiceNumber = invoiceNumber;
            return this;
        }
        
        /**
         * Set orderNumber
         * @param orderNumber Sales order number. Length &#x3D; 17. (optional, default to Optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder orderNumber(String orderNumber) {
            this.orderNumber = orderNumber;
            return this;
        }
        
        /**
         * Set orderDateFrom
         * @param orderDateFrom Sales order Date. (optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder orderDateFrom(LocalDate orderDateFrom) {
            this.orderDateFrom = orderDateFrom;
            return this;
        }
        
        /**
         * Set orderDateTo
         * @param orderDateTo Sales order Date. (optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder orderDateTo(LocalDate orderDateTo) {
            this.orderDateTo = orderDateTo;
            return this;
        }
        
        /**
         * Set timeStampFrom
         * @param timeStampFrom Sales TimeStamp. (optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder timeStampFrom(LocalDate timeStampFrom) {
            this.timeStampFrom = timeStampFrom;
            return this;
        }
        
        /**
         * Set timeStampTo
         * @param timeStampTo Sales TimeStamp. (optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder timeStampTo(LocalDate timeStampTo) {
            this.timeStampTo = timeStampTo;
            return this;
        }
        
        /**
         * Set status
         * @param status Sales status. Allowed values:  1. Transaction - Approved 2. Transaction - Declined 3. Transaction - Created - Local 4. Transaction - Created - Error: Processor not reached 5. Transaction - Processor Error 6. Transaction - Approved - Warning (optional, default to Optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder status(String status) {
            this.status = status;
            return this;
        }
        
        /**
         * Set merchantCustomerId
         * @param merchantCustomerId Merchant Customer Id. (optional, default to Optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder merchantCustomerId(String merchantCustomerId) {
            this.merchantCustomerId = merchantCustomerId;
            return this;
        }
        
        /**
         * Set activated
         * @param activated Delayed Activation Sales to be included or not (optional, default to false)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder activated(Boolean activated) {
            this.activated = activated;
            return this;
        }
        
        /**
         * Set activationDateFrom
         * @param activationDateFrom Activation Start Date. This field is applicable only when Activated flag is set to true. (optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder activationDateFrom(LocalDate activationDateFrom) {
            this.activationDateFrom = activationDateFrom;
            return this;
        }
        
        /**
         * Set activationDateTo
         * @param activationDateTo Activation End Date. This field is applicable only when Activated flag is set to true. (optional)
         * @return SearchSalesRequestBuilder
         */
        public SearchSalesRequestBuilder activationDateTo(LocalDate activationDateTo) {
            this.activationDateTo = activationDateTo;
            return this;
        }
        
        /**
         * Build call for searchSales
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SaleSearchSalesRequest saleSearchSalesRequest = buildBodyParams();
            return searchSalesCall(exportable, pageNumber, pageSize, saleSearchSalesRequest, _callback);
        }

        private SaleSearchSalesRequest buildBodyParams() {
            SaleSearchSalesRequest saleSearchSalesRequest = new SaleSearchSalesRequest();
            saleSearchSalesRequest.merchantGuid(this.merchantGuid);
            saleSearchSalesRequest.amountFrom(this.amountFrom);
            saleSearchSalesRequest.amountTo(this.amountTo);
            saleSearchSalesRequest.cardHolderName(this.cardHolderName);
            saleSearchSalesRequest.cardLastFour(this.cardLastFour);
            saleSearchSalesRequest.cardType(this.cardType);
            saleSearchSalesRequest.invoiceNumber(this.invoiceNumber);
            saleSearchSalesRequest.orderNumber(this.orderNumber);
            saleSearchSalesRequest.orderDateFrom(this.orderDateFrom);
            saleSearchSalesRequest.orderDateTo(this.orderDateTo);
            saleSearchSalesRequest.timeStampFrom(this.timeStampFrom);
            saleSearchSalesRequest.timeStampTo(this.timeStampTo);
            saleSearchSalesRequest.status(this.status);
            saleSearchSalesRequest.merchantCustomerId(this.merchantCustomerId);
            saleSearchSalesRequest.activated(this.activated);
            saleSearchSalesRequest.activationDateFrom(this.activationDateFrom);
            saleSearchSalesRequest.activationDateTo(this.activationDateTo);
            return saleSearchSalesRequest;
        }

        /**
         * Execute searchSales request
         * @return SaleSearchSalesResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public SaleSearchSalesResponse execute() throws ApiException {
            SaleSearchSalesRequest saleSearchSalesRequest = buildBodyParams();
            ApiResponse<SaleSearchSalesResponse> localVarResp = searchSalesWithHttpInfo(exportable, pageNumber, pageSize, saleSearchSalesRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute searchSales request with HTTP info returned
         * @return ApiResponse&lt;SaleSearchSalesResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<SaleSearchSalesResponse> executeWithHttpInfo() throws ApiException {
            SaleSearchSalesRequest saleSearchSalesRequest = buildBodyParams();
            return searchSalesWithHttpInfo(exportable, pageNumber, pageSize, saleSearchSalesRequest);
        }

        /**
         * Execute searchSales request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<SaleSearchSalesResponse> _callback) throws ApiException {
            SaleSearchSalesRequest saleSearchSalesRequest = buildBodyParams();
            return searchSalesAsync(exportable, pageNumber, pageSize, saleSearchSalesRequest, _callback);
        }
    }

    /**
     * Search sales
     * This endpoint searches sales.
     * @param exportable True or False. It means if you want results exportable to CSV. (required)
     * @param pageNumber Int. Number of page of the results. Default is 1 (Page size default is 500). (required)
     * @param pageSize Int. Size of each page of the results. Default is 500. (required)
     * @return SearchSalesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
     </table>
     */
    public SearchSalesRequestBuilder searchSales(String exportable, Integer pageNumber, String pageSize) throws IllegalArgumentException {
        if (exportable == null) throw new IllegalArgumentException("\"exportable\" is required but got null");
            

        if (pageNumber == null) throw new IllegalArgumentException("\"pageNumber\" is required but got null");
        if (pageSize == null) throw new IllegalArgumentException("\"pageSize\" is required but got null");
            

        return new SearchSalesRequestBuilder(exportable, pageNumber, pageSize);
    }
    private okhttp3.Call updateDelayedActivationCall(SaleUpdateDelayedActivationRequest saleUpdateDelayedActivationRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = saleUpdateDelayedActivationRequest;

        // create path and map variables
        String localVarPath = "/api/v1/sales/UpdateFutureSale";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "sec0" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateDelayedActivationValidateBeforeCall(SaleUpdateDelayedActivationRequest saleUpdateDelayedActivationRequest, final ApiCallback _callback) throws ApiException {
        return updateDelayedActivationCall(saleUpdateDelayedActivationRequest, _callback);

    }


    private ApiResponse<String> updateDelayedActivationWithHttpInfo(SaleUpdateDelayedActivationRequest saleUpdateDelayedActivationRequest) throws ApiException {
        okhttp3.Call localVarCall = updateDelayedActivationValidateBeforeCall(saleUpdateDelayedActivationRequest, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateDelayedActivationAsync(SaleUpdateDelayedActivationRequest saleUpdateDelayedActivationRequest, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateDelayedActivationValidateBeforeCall(saleUpdateDelayedActivationRequest, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateDelayedActivationRequestBuilder {
        private final String deviceGuid;
        private final String saleGuid;
        private final Float amount;
        private LocalDate activationDate;

        private UpdateDelayedActivationRequestBuilder(String deviceGuid, String saleGuid, Float amount) {
            this.deviceGuid = deviceGuid;
            this.saleGuid = saleGuid;
            this.amount = amount;
        }

        /**
         * Set activationDate
         * @param activationDate Set a future date on which to run this sale, at least one day from creation date and within 600 days. (optional)
         * @return UpdateDelayedActivationRequestBuilder
         */
        public UpdateDelayedActivationRequestBuilder activationDate(LocalDate activationDate) {
            this.activationDate = activationDate;
            return this;
        }
        
        /**
         * Build call for updateDelayedActivation
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SaleUpdateDelayedActivationRequest saleUpdateDelayedActivationRequest = buildBodyParams();
            return updateDelayedActivationCall(saleUpdateDelayedActivationRequest, _callback);
        }

        private SaleUpdateDelayedActivationRequest buildBodyParams() {
            SaleUpdateDelayedActivationRequest saleUpdateDelayedActivationRequest = new SaleUpdateDelayedActivationRequest();
            saleUpdateDelayedActivationRequest.deviceGuid(this.deviceGuid);
            saleUpdateDelayedActivationRequest.saleGuid(this.saleGuid);
            saleUpdateDelayedActivationRequest.amount(this.amount);
            saleUpdateDelayedActivationRequest.activationDate(this.activationDate);
            return saleUpdateDelayedActivationRequest;
        }

        /**
         * Execute updateDelayedActivation request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            SaleUpdateDelayedActivationRequest saleUpdateDelayedActivationRequest = buildBodyParams();
            ApiResponse<String> localVarResp = updateDelayedActivationWithHttpInfo(saleUpdateDelayedActivationRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateDelayedActivation request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            SaleUpdateDelayedActivationRequest saleUpdateDelayedActivationRequest = buildBodyParams();
            return updateDelayedActivationWithHttpInfo(saleUpdateDelayedActivationRequest);
        }

        /**
         * Execute updateDelayedActivation request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            SaleUpdateDelayedActivationRequest saleUpdateDelayedActivationRequest = buildBodyParams();
            return updateDelayedActivationAsync(saleUpdateDelayedActivationRequest, _callback);
        }
    }

    /**
     * Update Delayed Sale
     * Updates the sale amount or activation date on a delayed activation sale.
     * @return UpdateDelayedActivationRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> 200 </td><td>  -  </td></tr>
     </table>
     */
    public UpdateDelayedActivationRequestBuilder updateDelayedActivation(String deviceGuid, String saleGuid, Float amount) throws IllegalArgumentException {
        if (deviceGuid == null) throw new IllegalArgumentException("\"deviceGuid\" is required but got null");
            

        if (saleGuid == null) throw new IllegalArgumentException("\"saleGuid\" is required but got null");
            

        if (amount == null) throw new IllegalArgumentException("\"amount\" is required but got null");
        return new UpdateDelayedActivationRequestBuilder(deviceGuid, saleGuid, amount);
    }
}
