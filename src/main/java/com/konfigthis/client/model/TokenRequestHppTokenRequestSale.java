/*
 * ConnexPay Reporting API
 * REST API for retrieving reporting data. Currently Daily Accounting data only.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * TokenRequestHppTokenRequestSale
 */@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class TokenRequestHppTokenRequestSale {
  public static final String SERIALIZED_NAME_DEVICE_GUID = "DeviceGuid";
  @SerializedName(SERIALIZED_NAME_DEVICE_GUID)
  private String deviceGuid;

  public static final String SERIALIZED_NAME_AMOUNT = "Amount";
  @SerializedName(SERIALIZED_NAME_AMOUNT)
  private Long amount;

  public static final String SERIALIZED_NAME_TENDER_TYPE = "TenderType";
  @SerializedName(SERIALIZED_NAME_TENDER_TYPE)
  private String tenderType;

  public static final String SERIALIZED_NAME_SEQUENCE_NUMBER = "SequenceNumber";
  @SerializedName(SERIALIZED_NAME_SEQUENCE_NUMBER)
  private String sequenceNumber;

  public static final String SERIALIZED_NAME_ORDER_NUMBER = "OrderNumber";
  @SerializedName(SERIALIZED_NAME_ORDER_NUMBER)
  private String orderNumber;

  public static final String SERIALIZED_NAME_SEND_RECEIPT = "SendReceipt";
  @SerializedName(SERIALIZED_NAME_SEND_RECEIPT)
  private Boolean sendReceipt;

  public static final String SERIALIZED_NAME_RISK_PROCESSING_ONLY = "RiskProcessingOnly";
  @SerializedName(SERIALIZED_NAME_RISK_PROCESSING_ONLY)
  private Boolean riskProcessingOnly;

  public static final String SERIALIZED_NAME_STATEMENT_DESCRIPTION = "StatementDescription";
  @SerializedName(SERIALIZED_NAME_STATEMENT_DESCRIPTION)
  private String statementDescription;

  public static final String SERIALIZED_NAME_CUSTOMER_I_D = "CustomerID";
  @SerializedName(SERIALIZED_NAME_CUSTOMER_I_D)
  private String customerID;

  public static final String SERIALIZED_NAME_ACTIVATION_DATE = "ActivationDate";
  @SerializedName(SERIALIZED_NAME_ACTIVATION_DATE)
  private String activationDate;

  public static final String SERIALIZED_NAME_GROUP_ID = "GroupId";
  @SerializedName(SERIALIZED_NAME_GROUP_ID)
  private String groupId;

  public TokenRequestHppTokenRequestSale() {
  }

  public TokenRequestHppTokenRequestSale deviceGuid(String deviceGuid) {
    
    
    
    
    this.deviceGuid = deviceGuid;
    return this;
  }

   /**
   * Device&#39;s Guid provided by ConnexPay
   * @return deviceGuid
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Device's Guid provided by ConnexPay")

  public String getDeviceGuid() {
    return deviceGuid;
  }


  public void setDeviceGuid(String deviceGuid) {
    
    
    
    this.deviceGuid = deviceGuid;
  }


  public TokenRequestHppTokenRequestSale amount(Long amount) {
    
    
    
    
    this.amount = amount;
    return this;
  }

   /**
   * Amount of the transaction that will be processed. Note: this value is submitted multiple times (in different formats) within the integration to support different purposes i.e. risk analysis, merchant processinging, etc.  The minimun amount is: $0.50.
   * @return amount
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Amount of the transaction that will be processed. Note: this value is submitted multiple times (in different formats) within the integration to support different purposes i.e. risk analysis, merchant processinging, etc.  The minimun amount is: $0.50.")

  public Long getAmount() {
    return amount;
  }


  public void setAmount(Long amount) {
    
    
    
    this.amount = amount;
  }


  public TokenRequestHppTokenRequestSale tenderType(String tenderType) {
    
    
    
    
    this.tenderType = tenderType;
    return this;
  }

   /**
   * Allowed values:  1. Credit (default if TenderType not provided) 2. Cash 3. ACH
   * @return tenderType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Allowed values:  1. Credit (default if TenderType not provided) 2. Cash 3. ACH")

  public String getTenderType() {
    return tenderType;
  }


  public void setTenderType(String tenderType) {
    
    
    
    this.tenderType = tenderType;
  }


  public TokenRequestHppTokenRequestSale sequenceNumber(String sequenceNumber) {
    
    
    
    
    this.sequenceNumber = sequenceNumber;
    return this;
  }

   /**
   * Transaction sequence number within client environment. Note: value is not searchable or reportable in ConnexPay portal.  Alphanumeric.
   * @return sequenceNumber
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Transaction sequence number within client environment. Note: value is not searchable or reportable in ConnexPay portal.  Alphanumeric.")

  public String getSequenceNumber() {
    return sequenceNumber;
  }


  public void setSequenceNumber(String sequenceNumber) {
    
    
    
    this.sequenceNumber = sequenceNumber;
  }


  public TokenRequestHppTokenRequestSale orderNumber(String orderNumber) {
    
    
    
    
    this.orderNumber = orderNumber;
    return this;
  }

   /**
   * This is the most common number you&#39;ll see throughout the ConnexPay Portal.  Transaction ID within client environment associated with the order. The value is searchable and reportable in the ConnexPay portal. This value may be sent in multiple instances of the integration for multiple purposes. Customers in the travel space often send the Record Locator/PNR in this field.  The maximum length is 50 alpha-numeric characters and allows dashes ( - ).
   * @return orderNumber
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "This is the most common number you'll see throughout the ConnexPay Portal.  Transaction ID within client environment associated with the order. The value is searchable and reportable in the ConnexPay portal. This value may be sent in multiple instances of the integration for multiple purposes. Customers in the travel space often send the Record Locator/PNR in this field.  The maximum length is 50 alpha-numeric characters and allows dashes ( - ).")

  public String getOrderNumber() {
    return orderNumber;
  }


  public void setOrderNumber(String orderNumber) {
    
    
    
    this.orderNumber = orderNumber;
  }


  public TokenRequestHppTokenRequestSale sendReceipt(Boolean sendReceipt) {
    
    
    
    
    this.sendReceipt = sendReceipt;
    return this;
  }

   /**
   * Value determines whether or not a customer shall be emailed a receipt from the ConnexPay platform if the email address is provided in the API customer block. The default value is TRUE. Set to FALSE so that an email receipt is not sent to the customer. Set to TRUE or leave empty if you want e-mail to be sent. If TRUE, customer&#39;s email must be included in the \&quot;Card.Customer.email\&quot; parameter.
   * @return sendReceipt
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Value determines whether or not a customer shall be emailed a receipt from the ConnexPay platform if the email address is provided in the API customer block. The default value is TRUE. Set to FALSE so that an email receipt is not sent to the customer. Set to TRUE or leave empty if you want e-mail to be sent. If TRUE, customer's email must be included in the \"Card.Customer.email\" parameter.")

  public Boolean getSendReceipt() {
    return sendReceipt;
  }


  public void setSendReceipt(Boolean sendReceipt) {
    
    
    
    this.sendReceipt = sendReceipt;
  }


  public TokenRequestHppTokenRequestSale riskProcessingOnly(Boolean riskProcessingOnly) {
    
    
    
    
    this.riskProcessingOnly = riskProcessingOnly;
    return this;
  }

   /**
   * Indicator that determines if client would like to evaluate the transactions as risk only rather than process as merchant of record and create a virtual card. The allowed values:  1. Set to TRUE will only run risk validations. If TenderType is set to Cash, setting TRUE will throw a validation error.  2. Set to FALSE will run risk validations and an authorization on the card. For this option a Processing Merchant account is required, contact ConnexPay support if any questions.  3. Set to NULL and your Merchant Level settings would apply.
   * @return riskProcessingOnly
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicator that determines if client would like to evaluate the transactions as risk only rather than process as merchant of record and create a virtual card. The allowed values:  1. Set to TRUE will only run risk validations. If TenderType is set to Cash, setting TRUE will throw a validation error.  2. Set to FALSE will run risk validations and an authorization on the card. For this option a Processing Merchant account is required, contact ConnexPay support if any questions.  3. Set to NULL and your Merchant Level settings would apply.")

  public Boolean getRiskProcessingOnly() {
    return riskProcessingOnly;
  }


  public void setRiskProcessingOnly(Boolean riskProcessingOnly) {
    
    
    
    this.riskProcessingOnly = riskProcessingOnly;
  }


  public TokenRequestHppTokenRequestSale statementDescription(String statementDescription) {
    
    
    
    
    this.statementDescription = statementDescription;
    return this;
  }

   /**
   * The statement description allows a client to customize the Merchant name that appears on the cardholder statement such that the cardholder recognizes the transaction on their statement. ConnexPay recommends sending a recognizable DBA along with the PNR i.e. ABC Travel ABC123. Note: functionality not applicable for American Express OptBlue program.  The maximun length is 25 alpha-numeric characters.
   * @return statementDescription
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The statement description allows a client to customize the Merchant name that appears on the cardholder statement such that the cardholder recognizes the transaction on their statement. ConnexPay recommends sending a recognizable DBA along with the PNR i.e. ABC Travel ABC123. Note: functionality not applicable for American Express OptBlue program.  The maximun length is 25 alpha-numeric characters.")

  public String getStatementDescription() {
    return statementDescription;
  }


  public void setStatementDescription(String statementDescription) {
    
    
    
    this.statementDescription = statementDescription;
  }


  public TokenRequestHppTokenRequestSale customerID(String customerID) {
    
    
    
    
    this.customerID = customerID;
    return this;
  }

   /**
   * Transaction ID within client environment associated with the customer. This value acts as a secondary identifier in conjunction with OrderNumber. The value is searchable and reportable in the ConnexPay portal. This value may be sent in multiple times within the integration for multiple purposes.  The maximum length is 50 characters and is alpha-numeric.
   * @return customerID
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Transaction ID within client environment associated with the customer. This value acts as a secondary identifier in conjunction with OrderNumber. The value is searchable and reportable in the ConnexPay portal. This value may be sent in multiple times within the integration for multiple purposes.  The maximum length is 50 characters and is alpha-numeric.")

  public String getCustomerID() {
    return customerID;
  }


  public void setCustomerID(String customerID) {
    
    
    
    this.customerID = customerID;
  }


  public TokenRequestHppTokenRequestSale activationDate(String activationDate) {
    
    
    
    
    this.activationDate = activationDate;
    return this;
  }

   /**
   * Set a future date on which to run this sale, at least one day from creation date and within one year. If this parameter is supplied a record for this sale is created, supplied consumer card information is internally tokenized, but fraud check and authorization do not occur until ConnexPay processes it on the supplied ActivationDate. Alternatively, a client can force activation via the Activate API (see below). If this date is not supplied a sale is authorized immediately.
   * @return activationDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Set a future date on which to run this sale, at least one day from creation date and within one year. If this parameter is supplied a record for this sale is created, supplied consumer card information is internally tokenized, but fraud check and authorization do not occur until ConnexPay processes it on the supplied ActivationDate. Alternatively, a client can force activation via the Activate API (see below). If this date is not supplied a sale is authorized immediately.")

  public String getActivationDate() {
    return activationDate;
  }


  public void setActivationDate(String activationDate) {
    
    
    
    this.activationDate = activationDate;
  }


  public TokenRequestHppTokenRequestSale groupId(String groupId) {
    
    
    
    
    this.groupId = groupId;
    return this;
  }

   /**
   * When needing to issue a Virtual Card that ties to more than one Sale transaction, you can send in a GroupId (with the same GroupId) on the Sales that you need to group together. By including a common GroupId for two or more Sales transaction, a Virtual Card may then be created for the sum of the Sales within that GroupId.  A common use case for this is when multiple families are going on a cruise - each family may want to pay separately on their credit card. However, the Travel Agent may want to pay for the cruise with one virtual card.  The maximum length is 25 alpha-numeric characters.  This is for limited use - please contact your Customer Success Manager if you would like to enable this functionality.
   * @return groupId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "When needing to issue a Virtual Card that ties to more than one Sale transaction, you can send in a GroupId (with the same GroupId) on the Sales that you need to group together. By including a common GroupId for two or more Sales transaction, a Virtual Card may then be created for the sum of the Sales within that GroupId.  A common use case for this is when multiple families are going on a cruise - each family may want to pay separately on their credit card. However, the Travel Agent may want to pay for the cruise with one virtual card.  The maximum length is 25 alpha-numeric characters.  This is for limited use - please contact your Customer Success Manager if you would like to enable this functionality.")

  public String getGroupId() {
    return groupId;
  }


  public void setGroupId(String groupId) {
    
    
    
    this.groupId = groupId;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the TokenRequestHppTokenRequestSale instance itself
   */
  public TokenRequestHppTokenRequestSale putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TokenRequestHppTokenRequestSale tokenRequestHppTokenRequestSale = (TokenRequestHppTokenRequestSale) o;
    return Objects.equals(this.deviceGuid, tokenRequestHppTokenRequestSale.deviceGuid) &&
        Objects.equals(this.amount, tokenRequestHppTokenRequestSale.amount) &&
        Objects.equals(this.tenderType, tokenRequestHppTokenRequestSale.tenderType) &&
        Objects.equals(this.sequenceNumber, tokenRequestHppTokenRequestSale.sequenceNumber) &&
        Objects.equals(this.orderNumber, tokenRequestHppTokenRequestSale.orderNumber) &&
        Objects.equals(this.sendReceipt, tokenRequestHppTokenRequestSale.sendReceipt) &&
        Objects.equals(this.riskProcessingOnly, tokenRequestHppTokenRequestSale.riskProcessingOnly) &&
        Objects.equals(this.statementDescription, tokenRequestHppTokenRequestSale.statementDescription) &&
        Objects.equals(this.customerID, tokenRequestHppTokenRequestSale.customerID) &&
        Objects.equals(this.activationDate, tokenRequestHppTokenRequestSale.activationDate) &&
        Objects.equals(this.groupId, tokenRequestHppTokenRequestSale.groupId)&&
        Objects.equals(this.additionalProperties, tokenRequestHppTokenRequestSale.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(deviceGuid, amount, tenderType, sequenceNumber, orderNumber, sendReceipt, riskProcessingOnly, statementDescription, customerID, activationDate, groupId, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TokenRequestHppTokenRequestSale {\n");
    sb.append("    deviceGuid: ").append(toIndentedString(deviceGuid)).append("\n");
    sb.append("    amount: ").append(toIndentedString(amount)).append("\n");
    sb.append("    tenderType: ").append(toIndentedString(tenderType)).append("\n");
    sb.append("    sequenceNumber: ").append(toIndentedString(sequenceNumber)).append("\n");
    sb.append("    orderNumber: ").append(toIndentedString(orderNumber)).append("\n");
    sb.append("    sendReceipt: ").append(toIndentedString(sendReceipt)).append("\n");
    sb.append("    riskProcessingOnly: ").append(toIndentedString(riskProcessingOnly)).append("\n");
    sb.append("    statementDescription: ").append(toIndentedString(statementDescription)).append("\n");
    sb.append("    customerID: ").append(toIndentedString(customerID)).append("\n");
    sb.append("    activationDate: ").append(toIndentedString(activationDate)).append("\n");
    sb.append("    groupId: ").append(toIndentedString(groupId)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("DeviceGuid");
    openapiFields.add("Amount");
    openapiFields.add("TenderType");
    openapiFields.add("SequenceNumber");
    openapiFields.add("OrderNumber");
    openapiFields.add("SendReceipt");
    openapiFields.add("RiskProcessingOnly");
    openapiFields.add("StatementDescription");
    openapiFields.add("CustomerID");
    openapiFields.add("ActivationDate");
    openapiFields.add("GroupId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("DeviceGuid");
    openapiRequiredFields.add("Amount");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to TokenRequestHppTokenRequestSale
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!TokenRequestHppTokenRequestSale.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TokenRequestHppTokenRequestSale is not found in the empty JSON string", TokenRequestHppTokenRequestSale.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TokenRequestHppTokenRequestSale.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("DeviceGuid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `DeviceGuid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("DeviceGuid").toString()));
      }
      if ((jsonObj.get("TenderType") != null && !jsonObj.get("TenderType").isJsonNull()) && !jsonObj.get("TenderType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TenderType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TenderType").toString()));
      }
      if ((jsonObj.get("SequenceNumber") != null && !jsonObj.get("SequenceNumber").isJsonNull()) && !jsonObj.get("SequenceNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `SequenceNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("SequenceNumber").toString()));
      }
      if ((jsonObj.get("OrderNumber") != null && !jsonObj.get("OrderNumber").isJsonNull()) && !jsonObj.get("OrderNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `OrderNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("OrderNumber").toString()));
      }
      if ((jsonObj.get("StatementDescription") != null && !jsonObj.get("StatementDescription").isJsonNull()) && !jsonObj.get("StatementDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `StatementDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("StatementDescription").toString()));
      }
      if ((jsonObj.get("CustomerID") != null && !jsonObj.get("CustomerID").isJsonNull()) && !jsonObj.get("CustomerID").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CustomerID` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CustomerID").toString()));
      }
      if ((jsonObj.get("ActivationDate") != null && !jsonObj.get("ActivationDate").isJsonNull()) && !jsonObj.get("ActivationDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ActivationDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ActivationDate").toString()));
      }
      if ((jsonObj.get("GroupId") != null && !jsonObj.get("GroupId").isJsonNull()) && !jsonObj.get("GroupId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `GroupId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("GroupId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TokenRequestHppTokenRequestSale.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TokenRequestHppTokenRequestSale' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TokenRequestHppTokenRequestSale> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TokenRequestHppTokenRequestSale.class));

       return (TypeAdapter<T>) new TypeAdapter<TokenRequestHppTokenRequestSale>() {
           @Override
           public void write(JsonWriter out, TokenRequestHppTokenRequestSale value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public TokenRequestHppTokenRequestSale read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             TokenRequestHppTokenRequestSale instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TokenRequestHppTokenRequestSale given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TokenRequestHppTokenRequestSale
  * @throws IOException if the JSON string is invalid with respect to TokenRequestHppTokenRequestSale
  */
  public static TokenRequestHppTokenRequestSale fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TokenRequestHppTokenRequestSale.class);
  }

 /**
  * Convert an instance of TokenRequestHppTokenRequestSale to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

